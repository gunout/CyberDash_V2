<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BEATSTREET CYBERDASH - Selection Manager</title>
    
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary-cyan: #00ffff;
            --neon-blue: #00f3ff;
            --dark-cyan: #0088aa;
            --accent-blue: #0099ff;
            --bg-dark: #020205;
            --bg-panel: rgba(5, 15, 30, 0.9);
            --text-primary: #e0faff;
            --text-secondary: #00cccc;
            --danger-red: #ff3333;
            --success-green: #00ff66;
            --glow-cyan: 0 0 10px rgba(0, 255, 255, 0.6), 0 0 20px rgba(0, 255, 255, 0.4);
            --glow-strong: 0 0 15px var(--neon-blue), 0 0 30px var(--primary-cyan);
        }

        body {
            background: linear-gradient(135deg, #020205 0%, #050a15 50%, #0a0f20 100%);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Background Effects */
        .cyber-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index:1; }
        .particle {
            position: absolute; width: 2px; height: 2px; background: var(--primary-cyan);
            border-radius: 50%; box-shadow: var(--glow-cyan); animation: float 20s infinite linear;
        }
        @keyframes float {
            0% { transform: translateY(100vh) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) translateX(100px); opacity: 0; }
        }
        .grid-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(rgba(0,255,255, 0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,255,255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px; pointer-events: none; z-index: 2;
        }

        /* Layout */
        .dashboard {
            position: relative; z-index: 10;
            height: 100%;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            padding: 20px;
        }

        /* Header */
        .header {
            background: rgba(0, 20, 30, 0.7); border: 1px solid var(--primary-cyan);
            border-radius: 10px; padding: 15px 25px; backdrop-filter: blur(15px);
            box-shadow: var(--glow-cyan); display: flex; justify-content: space-between; align-items: center;
        }
        .logo {
            font-family: 'Orbitron', monospace; font-size: 24px; font-weight: 900;
            text-transform: uppercase; letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--primary-cyan));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .status-bar { display: flex; gap: 15px; font-family: 'Orbitron', monospace; font-size: 12px; }
        .status-item { color: var(--text-secondary); display: flex; align-items: center; gap: 5px; }
        .status-dot { width: 8px; height: 8px; background: var(--primary-cyan); border-radius: 50%; box-shadow: var(--glow-cyan); }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr 250px;
            gap: 20px;
            min-height: 0; 
        }

        /* Panels */
        .panel {
            background: var(--bg-panel); border: 1px solid var(--dark-cyan);
            border-radius: 10px; padding: 15px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .panel-title {
            font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 700;
            color: var(--primary-cyan); margin-bottom: 15px; border-bottom: 1px solid var(--dark-cyan);
            padding-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* Bouton Select All */
        .select-all-btn {
            background: transparent; border: 1px solid var(--primary-cyan);
            color: var(--primary-cyan); padding: 4px 10px; border-radius: 4px;
            font-family: 'Rajdhani', sans-serif; font-size: 11px; cursor: pointer;
            transition: all 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .select-all-btn:hover { background: rgba(0, 255, 255, 0.1); box-shadow: 0 0 10px var(--primary-cyan); }
        .select-all-btn i { font-size: 10px; }

        /* Playlist Container */
        .playlist-container {
            flex: 1; overflow-y: auto; overflow-x: hidden; margin-bottom: 15px; padding-right: 5px;
        }
        .playlist-container::-webkit-scrollbar { width: 10px; }
        .playlist-container::-webkit-scrollbar-track { background: rgba(0, 20, 40, 0.6); border-radius: 5px; }
        .playlist-container::-webkit-scrollbar-thumb { background: var(--dark-cyan); border-radius: 5px; border: 1px solid rgba(0,0,0,0.2); }
        .playlist-container::-webkit-scrollbar-thumb:hover { background: var(--primary-cyan); box-shadow: 0 0 10px var(--primary-cyan); }

        /* Playlist Item */
        .playlist-item {
            background: rgba(0,255,255, 0.03); border-left: 3px solid var(--dark-cyan);
            padding: 10px; margin-bottom: 5px; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 10px; position: relative;
        }
        
        .cyber-check {
            width: 18px; height: 18px; border: 1px solid var(--primary-cyan);
            background: rgba(0, 0, 0, 0.5); cursor: pointer; position: relative;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; flex-shrink: 0;
        }
        .cyber-check:hover { background: rgba(0, 255, 255, 0.1); box-shadow: 0 0 10px var(--primary-cyan); }
        .cyber-check.checked { background: var(--primary-cyan); box-shadow: 0 0 10px var(--primary-cyan); }
        .cyber-check.checked::after { content: '✓'; color: #000; font-weight: bold; font-size: 12px; }

        .delete-btn {
            opacity: 0; background: var(--danger-red); color: #fff; width: 24px; height: 24px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; position: absolute; right: -10px;
        }
        .playlist-item:hover .delete-btn { opacity: 1; right: 10px; }
        .delete-btn:hover { transform: scale(1.2); box-shadow: 0 0 10px var(--danger-red); }

        .playlist-item:hover {
            background: rgba(0,255,255, 0.1); border-left-color: var(--primary-cyan);
            transform: translateX(2px);
        }
        .playlist-item.active { background: rgba(0,255,255, 0.15); border-left-color: #fff; box-shadow: 0 0 10px rgba(0,255,255,0.1); }

        .track-info-wrapper { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px; }
        .track-path {
            font-size: 11px; color: var(--text-secondary); opacity: 0.8;
            font-family: monospace; display: flex; align-items: center; gap: 5px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .track-path i { color: var(--primary-cyan); font-size: 10px; }
        .track-name {
            font-size: 13px; font-weight: 600; color: #fff;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: flex; align-items: center; gap: 8px;
        }

        .download-zip-btn {
            background: linear-gradient(45deg, var(--primary-cyan), var(--accent-blue));
            border: none; color: #000; padding: 12px; border-radius: 5px;
            font-family: 'Orbitron'; font-weight: 700; cursor: pointer; text-transform: uppercase;
            font-size: 12px; box-shadow: var(--glow-cyan); transition: 0.3s;
            display: flex; align-items: center; justify-content: center; gap: 8px; flex-shrink: 0;
        }
        .download-zip-btn:hover { transform: translateY(-2px); box-shadow: var(--glow-strong); }
        .download-zip-btn small { font-size: 10px; opacity: 0.8; }

        /* Center Media Deck */
        .media-deck { flex: 1; display: flex; flex-direction: column; }
        .deck-input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .cyber-input {
            flex:1; background: rgba(0, 10, 20, 0.9); border: 1px solid var(--dark-cyan);
            border-radius: 4px; padding: 10px; color: var(--primary-cyan);
            font-family: 'Rajdhani', sans-serif; font-size: 14px; outline: none;
        }
        .cyber-btn {
            background: rgba(0,255,255, 0.1); border: 1px solid var(--primary-cyan);
            color: var(--primary-cyan); padding: 0 20px; border-radius: 4px; cursor: pointer;
            font-family: 'Orbitron', monospace; font-weight: 700; text-transform: uppercase;
            transition: all 0.3s;
        }
        .cyber-btn:hover { background: var(--primary-cyan); color: #000; box-shadow: var(--glow-cyan); }

        .screen-container {
            flex: 1; background: #000; border: 1px solid var(--dark-cyan); border-radius: 8px;
            position: relative; overflow: hidden; display: flex; flex-direction: column;
        }
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 20;
        }
        .corner-decor { position: absolute; width: 15px; height: 15px; border: 2px solid var(--primary-cyan); opacity: 0.5; z-index: 21; }
        .tl { top: 10px; left: 10px; border-right: none; border-bottom: none; }
        .br { bottom: 10px; right: 10px; border-left: none; border-top: none; }

        .screen-content { flex: 1; position: relative; display: none; justify-content: center; align-items: center; }
        .screen-content.active { display: flex; }

        .yt-placeholder { 
            position: absolute; text-align: center; color: var(--dark-cyan); z-index: 2;
            width: 100%; height: 100%; display: flex; flex-direction: column;
            justify-content: center; align-items: center; background: rgba(0,0,0,0.9);
        }
        .yt-placeholder i { font-size: 50px; margin-bottom: 15px; opacity: 0.3; }
        
        .yt-player-container { width: 100%; height: 100%; position: relative; z-index: 10; }
        .yt-player-container iframe { width: 100%; height=100%; border: none; }

        .audio-player-ui {
            width: 100%; padding: 20px; text-align: center; color: var(--primary-cyan);
            display: flex; flex-direction: column; justify-content: center; gap: 20px; height: 100%;
        }
        .audio-info-title { font-family: 'Orbitron'; font-size: 18px; text-shadow: 0 0 10px var(--primary-cyan); word-break: break-all; }
        .audio-info-path { font-family: 'Rajdhani'; font-size: 14px; opacity: 0.7; }
        
        .audio-wave { height: 100px; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .bar { width: 10px; background: var(--primary-cyan); animation: wave 1s infinite ease-in-out; }
        @keyframes wave { 0%, 100% { height: 10px; opacity: 0.5; } 50% { height: 80px; opacity: 1; box-shadow: 0 0 10px var(--primary-cyan); } }
        
        .control-bar {
            background: rgba(0, 20, 30, 0.9); border-top: 1px solid var(--primary-cyan);
            padding: 12px; display: flex; justify-content: space-between; align-items: center; z-index: 25;
        }
        .bar-left { font-family: 'Orbitron'; font-size: 11px; color: var(--text-secondary); }
        .bar-controls { display: flex; gap: 10px; }
        .icon-btn {
            background: transparent; border: none; color: var(--primary-cyan); cursor: pointer; font-size: 18px;
            transition: 0.2s;
        }
        .icon-btn:hover { color: #fff; text-shadow: 0 0 10px var(--primary-cyan); transform: scale(1.1); }
        .mp3-action-btn {
            background: rgba(255, 0, 0, 0.1); border: 1px solid #ff3333; color: #ff3333;
            padding: 5px 12px; border-radius: 4px; cursor: pointer; font-family: 'Orbitron'; font-size: 10px;
            text-transform: uppercase; display: none;
        }
        .mp3-action-btn.show { display: block; }
        .mp3-action-btn:hover { background: #ff0000; color: #fff; }

        /* Scanner & Zip Overlays */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 3000;
        }
        .overlay-box {
            background: var(--bg-panel); border: 2px solid var(--primary-cyan); padding: 30px;
            width: 600px; text-align: center; border-radius: 10px; position: relative;
        }
        .scan-log {
            height: 200px; overflow-y: auto; background: #000; color: var(--primary-cyan);
            font-family: monospace; font-size: 11px; text-align: left; padding: 10px;
            border: 1px solid var(--dark-cyan); margin-top: 15px;
        }
        .scan-log .depth-1 { color: #00ffff; }
        .scan-log .found { color: #ff00ff; font-weight: bold; }
        .scan-log .error { color: #ff0000; }
        .zip-bar-bg { width: 100%; height: 10px; background: #000; margin: 20px 0; }
        .zip-bar-fill { height: 100%; background: var(--primary-cyan); width: 0%; transition: width 0.3s; }

        /* Custom Toast Notification */
        .toast-container {
            position: fixed; bottom: 30px; right: 30px; z-index: 5000;
            display: flex; flex-direction: column; gap: 10px;
        }
        .toast {
            background: rgba(0, 10, 20, 0.95); border: 1px solid var(--primary-cyan);
            color: var(--primary-cyan); padding: 15px 20px; border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); display: flex; align-items: center; gap: 10px;
            font-family: 'Orbitron', monospace; font-size: 12px; animation: slideIn 0.3s ease-out forwards;
            max-width: 400px;
        }
        .toast.success { border-color: var(--success-green); color: var(--success-green); }
        .toast.error { border-color: var(--danger-red); color: var(--danger-red); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOut { to { transform: translateX(100%); opacity: 0; } }

        @media(max-width: 900px) { .main-content { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="cyber-bg" id="cyberBg"></div>
    <div class="grid-overlay"></div>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="dashboard">
        <header class="header">
            <div class="logo">BEATSTREET <span style="color:var(--primary-cyan)">SELECTOR</span></div>
            <div class="status-bar">
                <div class="status-item"><div class="status-dot"></div> ONLINE</div>
                <div class="status-item"><div class="status-dot" style="background:#ffff00"></div> MANAGER</div>
            </div>
        </header>

        <main class="main-content">
            <!-- Playlist Panel -->
            <section class="panel">
                <div class="panel-title">
                    <span id="playlistTitle">DATA STREAM [0/0]</span>
                    <div>
                        <button class="select-all-btn" id="selectAllBtn">
                            <i class="fas fa-check-double"></i> SELECT ALL
                        </button>
                        <i class="fas fa-database"></i>
                    </div>
                </div>
                <div class="playlist-container" id="playlistContainer">
                    <div style="text-align:center; color:var(--text-secondary); padding:30px; opacity:0.5;">NO DATA</div>
                </div>
                <button class="download-zip-btn" id="downloadZipBtn">
                    <i class="fas fa-file-archive"></i> ZIP SELECTED
                    <small id="selectedCountBadge">(0)</small>
                </button>
            </section>

            <!-- Media Deck Panel -->
            <section class="panel media-deck">
                <div class="deck-input-group">
                    <input type="text" class="cyber-input" id="urlInput" placeholder="ENTER YOUTUBE URL OR MP3 LINK...">
                    <button class="cyber-btn" id="loadBtn">LOAD</button>
                </div>

                <div class="screen-container" id="screenContainer">
                    <div class="corner-decor tl"></div>
                    <div class="corner-decor br"></div>
                    <div class="scanlines"></div>

                    <!-- Mode 1: YouTube -->
                    <div class="screen-content active" id="ytScreen">
                        <div class="yt-placeholder" id="ytPlaceholder">
                            <i class="fab fa-youtube"></i><br>READY TO PLAY
                        </div>
                        <div class="yt-player-container" id="ytPlayerContainer"></div>
                    </div>

                    <!-- Mode 2: Audio -->
                    <div class="screen-content" id="audioScreen">
                        <div class="audio-player-ui">
                            <div class="audio-info-title" id="audioTitle">NO TRACK</div>
                            <div class="audio-info-path" id="audioPath">WAITING...</div>
                            <div class="audio-wave">
                                <div class="bar" style="animation-delay:0.1s"></div>
                                <div class="bar" style="animation-delay:0.3s"></div>
                                <div class="bar" style="animation-delay:0.5s"></div>
                                <div class="bar" style="animation-delay:0.2s"></div>
                                <div class="bar" style="animation-delay:0.4s"></div>
                            </div>
                        </div>
                        <audio id="html5Audio" controls style="width:100%; position:absolute; bottom:0; opacity:0;"></audio>
                    </div>
                </div>

                <div class="control-bar">
                    <div class="bar-left">
                        <span id="modeIndicator">MODE: YOUTUBE</span>
                        <br>
                        <span id="statusIndicator" style="color:var(--primary-cyan)">READY</span>
                    </div>
                    <div class="bar-controls">
                        <button class="icon-btn" id="prevBtn"><i class="fas fa-step-backward"></i></button>
                        <button class="icon-btn" id="playPauseBtn"><i class="fas fa-play"></i></button>
                        <button class="icon-btn" id="nextBtn"><i class="fas fa-step-forward"></i></button>
                        <button class="mp3-action-btn" id="mp3ActionBtn"><i class="fas fa-download"></i> GET MP3</button>
                    </div>
                </div>
            </section>

            <!-- Settings -->
            <section class="panel">
                <div class="panel-title">CONTROLS</div>
                <div style="margin-top:auto; text-align:center;">
                    <button class="cyber-btn" onclick="openScanner()" style="width:100%; margin-bottom:10px; border-color:var(--accent-blue); color:var(--accent-blue);">
                        <i class="fas fa-search"></i> DEEP SCAN
                    </button>
                    <button class="cyber-btn" id="clearPlaylistBtn" style="width:100%; background:rgba(255,0,0,0.1); border-color:red; color:red;">
                        <i class="fas fa-trash"></i> CLEAR ALL
                    </button>
                </div>
            </section>
        </main>
    </div>

    <!-- SCANNER OVERLAY -->
    <div class="overlay" id="scannerOverlay">
        <div class="overlay-box">
            <h2 style="font-family:'Orbitron'; color:var(--primary-cyan);">RECURSIVE CRAWLER</h2>
            <input type="text" class="cyber-input" id="scanInput" value="http://hoj-clan.fr/Music/Skid%20Row/" style="margin-top:20px;">
            <div class="scan-log" id="scanLog">> System ready...</div>
            <div style="margin-top:15px;">
                <button class="cyber-btn" id="startScanBtn" style="background:rgba(0,255,0,0.1); border-color:#0f0; color:#0f0;">START CRAWL</button>
                <button class="cyber-btn" id="stopScanBtn" style="background:rgba(255,0,0,0.1); border-color:red; color:red; display:none;">
                    <i class="fas fa-stop"></i> STOP SCAN
                </button>
                <button class="cyber-btn" onclick="closeScanner()" style="margin-left:10px;">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- ZIP PROGRESS OVERLAY -->
    <div class="overlay" id="zipOverlay">
        <div class="overlay-box" style="width: 600px;">
            <h2 style="font-family:'Orbitron'; color:var(--primary-cyan); margin-bottom:15px;">CREATING ARCHIVE</h2>
            <div id="zipStatusText">Organizing folders...</div>
            <div class="zip-bar-bg">
                <div class="zip-bar-fill" id="zipProgressBar"></div>
            </div>
            <div id="zipSpeedInfo" style="margin-top:10px; font-size:12px; color:var(--text-secondary);"></div>
            <div style="margin-top:15px;">
                <button class="cyber-btn" id="cancelZipBtn" style="background:rgba(255,0,0,0.1); border-color:red; color:red; display:none;">
                    <i class="fas fa-stop"></i> CANCEL
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- NOTIFICATION SYSTEM ---
        function showNotification(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            let icon = 'fa-info-circle';
            if(type === 'success') icon = 'fa-check-circle';
            if(type === 'error') icon = 'fa-exclamation-triangle';
            
            toast.innerHTML = `<i class="fas ${icon}"></i> <span>${message}</span>`;
            
            container.appendChild(toast);
            
            // Auto remove after 4s
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s forwards';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        // --- ENCODING FIX (Mojibake) ---
        function fixMojibake(str) {
            if (!str) return '';
            try {
                const encodings = [
                    { from: /Ã©/g, to: 'é' },
                    { from: /Ã¨/g, to: 'è' },
                    { from: /Ã¢/g, to: 'â' },
                    { from: /Ã´/g, to: 'ô' },
                    { from: /Ã¹/g, to: 'ù' },
                    { from: /Ãª/g, to: 'ê' },
                    { from: /Ã®/g, to: 'î' },
                    { from: /Ã«/g, to: 'ë' },
                    { from: /Ã¯/g, to: 'ï' },
                    { from: /Ã /g, to: 'à' },
                    { from: /Ã§/g, to: 'ç' },
                    { from: /Ãœ/g, to: 'Ü' },
                    { from: /Ã¶/g, to: 'ö' },
                    { from: /Ã¼/g, to: 'ü' },
                    { from: /Ã¤/g, to: 'ä' },
                    { from: /â€™/g, to: "'" },
                    { from: /â€"/g, to: '"' },
                    { from: /â€“/g, to: '–' },
                    { from: /â€”/g, to: '—' },
                    { from: /â€¦/g, to: '…' },
                    { from: /â€˜/g, to: '‘' },
                    { from: /â€š/g, to: '‚' },
                    { from: /â€ž/g, to: '„' },
                    { from: /â€°/g, to: '°' },
                    { from: /â€¢/g, to: '•' },
                    { from: /â„¢/g, to: '™' },
                    { from: /Â®/g, to: '®' },
                    { from: /Â©/g, to: '©' }
                ];
                
                let result = str;
                encodings.forEach(enc => {
                    result = result.replace(enc.from, enc.to);
                });
                
                return result;
            } catch (e) {
                return str;
            }
        }

        // --- PARTICLES ---
        const cyberBg = document.getElementById('cyberBg');
        for(let i=0; i<40; i++) {
            const p = document.createElement('div'); p.className='particle';
            p.style.left = Math.random()*100+'%'; p.style.animationDelay = Math.random()*20+'s';
            cyberBg.appendChild(p);
        }

        // --- STATE ---
        let playlist = [];
        let selectedUids = new Set();
        let currentIndex = -1;
        let currentMediaItem = null;
        let isSelectAll = false;
        let currentYouTubePlayer = null;
        let zipGenerator = null;

        // --- DOM ---
        const screens = { yt: document.getElementById('ytScreen'), audio: document.getElementById('audioScreen') };
        const urlInput = document.getElementById('urlInput');
        const loadBtn = document.getElementById('loadBtn');
        const modeIndicator = document.getElementById('modeIndicator');
        const statusIndicator = document.getElementById('statusIndicator');
        const playlistTitle = document.getElementById('playlistTitle');
        const selectedCountBadge = document.getElementById('selectedCountBadge');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const ytPlaceholder = document.getElementById('ytPlaceholder');
        const ytPlayerContainer = document.getElementById('ytPlayerContainer');
        const audioEl = document.getElementById('html5Audio');
        const audioTitle = document.getElementById('audioTitle');
        const audioPath = document.getElementById('audioPath');
        const mp3ActionBtn = document.getElementById('mp3ActionBtn');

        // --- YOUTUBE PLAYER ---
        class SmartYouTubePlayer {
            constructor() {
                this.availableMethods = ['githubMethod', 'invidiousMethod', 'liteMethod', 'embedMethod'];
            }
            githubMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        const iframe = document.createElement('iframe');
                        iframe.id = 'ytGithubPlayer';
                        iframe.src = `https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1&autoplay=${autoplay ? 1 : 0}&playsinline=1`;
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
                        ytPlayerContainer.appendChild(iframe);
                        setTimeout(() => { ytPlaceholder.style.display = 'none'; resolve(true); }, 1500);
                    } catch (error) { reject(error); }
                });
            }
            invidiousMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        const iframe = document.createElement('iframe');
                        const instances = [`https://invidious.nerdvpn.de/embed/${videoId}`, `https://y.com.sb/embed/${videoId}`];
                        iframe.src = `${instances[0]}?autoplay=${autoplay ? 1 : 0}`;
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
                        ytPlayerContainer.appendChild(iframe);
                        setTimeout(() => { ytPlaceholder.style.display = 'none'; resolve(true); }, 1000);
                    } catch (error) { reject(error); }
                });
            }
            liteMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        const litePlayer = document.createElement('div');
                        litePlayer.innerHTML = `<iframe src="https://www.youtube.com/embed/${videoId}?rel=0&autoplay=${autoplay ? 1 : 0}" style="width:100%; height:100%; border:none;" allowfullscreen></iframe>`;
                        ytPlayerContainer.appendChild(litePlayer);
                        setTimeout(() => { ytPlaceholder.style.display = 'none'; resolve(true); }, 1000);
                    } catch (error) { reject(error); }
                });
            }
            embedMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        const iframe = document.createElement('iframe');
                        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=${autoplay ? 1 : 0}`;
                        iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
                        iframe.setAttribute('allowfullscreen', '');
                        ytPlayerContainer.appendChild(iframe);
                        setTimeout(() => { ytPlaceholder.style.display = 'none'; resolve(true); }, 1000);
                    } catch (error) { reject(error); }
                });
            }
            async playVideo(videoId, autoplay = false) {
                ytPlaceholder.style.display = 'flex';
                ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>INITIALIZING PLAYER...`;
                for (const method of this.availableMethods) {
                    try {
                        await this[method](videoId, autoplay);
                        statusIndicator.textContent = autoplay ? "PLAYING" : "READY";
                        const playBtnIcon = document.querySelector('#playPauseBtn i');
                        playBtnIcon.className = autoplay ? 'fas fa-pause' : 'fas fa-play';
                        return true;
                    } catch (error) { console.warn(`Method ${method} failed`); continue; }
                }
                ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>PLAYER ERROR`;
                return false;
            }
            stop() {
                ytPlayerContainer.innerHTML = '';
                ytPlaceholder.style.display = 'flex';
                ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>READY TO PLAY`;
            }
        }
        const youtubePlayer = new SmartYouTubePlayer();

        // --- OPTIMIZED ZIP GENERATOR FOR LARGE COLLECTIONS ---
        class OptimizedZipGenerator {
            constructor() {
                this.maxWorkers = 8;
                this.maxRetries = 3;
                this.timeout = 30000;
                this.batchSize = 50;
                this.progress = 0;
                this.totalFiles = 0;
                this.processedFiles = 0;
                this.startTime = null;
                this.successCount = 0;
                this.failedCount = 0;
                this.abortController = null;
                this.isProcessing = false;
                this.cache = new Map();
                this.maxConcurrentDownloads = 6;
                this.activeDownloads = 0;
            }

            cleanFileName(filename) {
                if (!filename) return 'unknown.mp3';
                
                let clean = decodeURIComponent(filename);
                clean = fixMojibake(clean);
                
                clean = clean
                    .replace(/[<>:"|?*\x00-\x1F\x7F]/g, '_')
                    .replace(/\\/g, '-')
                    .replace(/\/+/g, '/')
                    .replace(/\.\.+/g, '.')
                    .replace(/^[.\s]+|[.\s]+$/g, '')
                    .trim();
                
                if (!clean.toLowerCase().endsWith('.mp3')) {
                    clean = clean.replace(/\.(m4a|wav|flac|aac|ogg|wma)$/i, '');
                    clean += '.mp3';
                }
                
                if (clean.length > 150) {
                    const parts = clean.split('.');
                    const ext = parts.pop();
                    const name = parts.join('.').substring(0, 100);
                    clean = `${name}...${ext}`;
                }
                
                return clean;
            }

            cleanPath(path) {
                if (!path) return 'Music/';
                
                let cleanPath = decodeURIComponent(path);
                cleanPath = fixMojibake(cleanPath);
                
                const segments = cleanPath.split('/')
                    .filter(segment => segment.trim() !== '')
                    .map(segment => this.cleanFileName(segment));
                
                cleanPath = segments.join('/');
                
                if (!cleanPath.toLowerCase().startsWith('music/')) {
                    cleanPath = 'Music/' + cleanPath;
                }
                
                const maxDepth = 10;
                const pathSegments = cleanPath.split('/');
                if (pathSegments.length > maxDepth) {
                    cleanPath = pathSegments.slice(0, maxDepth).join('/') + '/.../' + 
                               pathSegments.slice(-1).join('/');
                }
                
                return cleanPath;
            }

            async createZip(items) {
                this.startTime = Date.now();
                this.abortController = new AbortController();
                
                const audioItems = items.filter(item => item.type === 'audio');
                this.totalFiles = audioItems.length;
                
                if (this.totalFiles === 0) {
                    throw new Error("No audio files to download");
                }
                
                document.getElementById('zipStatusText').textContent = 
                    `Preparing to download ${this.totalFiles.toLocaleString()} files...`;
                
                const zip = new JSZip();
                
                try {
                    await this.downloadInBatches(audioItems, zip);
                    
                    if (this.successCount === 0) {
                        throw new Error("No files were successfully downloaded");
                    }
                    
                    return zip;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error("Download cancelled by user");
                    }
                    throw error;
                }
            }

            async downloadInBatches(items, zip) {
                const batches = [];
                for (let i = 0; i < items.length; i += this.batchSize) {
                    batches.push(items.slice(i, i + this.batchSize));
                }
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    if (!this.isProcessing) break;
                    
                    const batch = batches[batchIndex];
                    const batchResults = await this.processBatch(batch, batchIndex + 1, batches.length);
                    
                    for (const [path, blob] of Object.entries(batchResults)) {
                        if (blob && blob.size > 1024) {
                            zip.file(path, blob);
                        }
                    }
                    
                    if (batchIndex % 5 === 0) {
                        await this.forceGarbageCollection();
                    }
                }
            }

            async processBatch(batch, batchNumber, totalBatches) {
                const results = {};
                const downloadTasks = [];
                
                for (const item of batch) {
                    const cacheKey = item.url;
                    if (this.cache.has(cacheKey)) {
                        results[this.getFinalPath(item)] = this.cache.get(cacheKey);
                        this.processedFiles++;
                        this.updateProgress();
                        continue;
                    }
                    
                    // Créer une fonction de tâche
                    const task = async () => {
                        try {
                            const blob = await this.downloadFileWithRetry(item.url);
                            if (blob && blob.size > 1024) {
                                const finalPath = this.getFinalPath(item);
                                results[finalPath] = blob;
                                this.cache.set(cacheKey, blob);
                                this.successCount++;
                            } else {
                                this.failedCount++;
                            }
                        } catch (error) {
                            console.warn(`Failed to download ${item.name}:`, error.message);
                            this.failedCount++;
                        } finally {
                            this.processedFiles++;
                            this.updateProgress(batchNumber, totalBatches);
                        }
                    };
                    
                    downloadTasks.push(task);
                }
                
                // Exécuter les tâches avec limitation de concurrence
                await this.runWithConcurrencyLimit(downloadTasks, this.maxConcurrentDownloads);
                
                return results;
            }

            async runWithConcurrencyLimit(tasks, limit) {
                const executing = [];
                const results = [];
                
                for (const task of tasks) {
                    // Vérifier si on doit arrêter
                    if (!this.isProcessing) {
                        break;
                    }
                    
                    // Créer une promesse pour la tâche
                    const p = task().then(result => {
                        executing.splice(executing.indexOf(p), 1);
                        return result;
                    });
                    
                    results.push(p);
                    executing.push(p);
                    
                    // Si on a atteint la limite, attendre qu'une tâche se termine
                    if (executing.length >= limit) {
                        await Promise.race(executing);
                    }
                }
                
                // Attendre que toutes les tâches en cours soient terminées
                await Promise.all(executing);
            }

            getFinalPath(item) {
                const cleanName = this.cleanFileName(item.name);
                const cleanPath = this.cleanPath(item.path);
                
                let finalPath = cleanPath;
                if (finalPath.endsWith('/')) {
                    finalPath += cleanName;
                } else if (!finalPath.includes('.')) {
                    finalPath += '/' + cleanName;
                } else {
                    finalPath = 'Music/' + cleanName;
                }
                
                return finalPath;
            }

            async downloadFileWithRetry(url) {
                let lastError;
                
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    if (!this.isProcessing) {
                        throw new Error("Download stopped");
                    }
                    
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
                        
                        const proxies = this.getProxies(url);
                        
                        for (const proxyUrl of proxies) {
                            try {
                                const response = await fetch(proxyUrl, {
                                    signal: controller.signal,
                                    headers: {
                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                    }
                                });
                                
                                clearTimeout(timeoutId);
                                
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                
                                const blob = await response.blob();
                                
                                if (blob.size < 1024) {
                                    throw new Error("File too small");
                                }
                                
                                if (!blob.type.includes('audio') && !blob.type.includes('octet-stream')) {
                                    console.warn(`Unexpected MIME type: ${blob.type}`);
                                }
                                
                                return blob;
                                
                            } catch (fetchError) {
                                if (fetchError.name === 'AbortError') {
                                    throw new Error("Download timeout");
                                }
                                continue;
                            }
                        }
                        
                        throw new Error("All proxies failed");
                        
                    } catch (error) {
                        lastError = error;
                        
                        if (attempt < this.maxRetries) {
                            const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
                
                throw lastError || new Error("Download failed after retries");
            }

            getProxies(url) {
                return [
                    `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                    `https://corsproxy.io/?${encodeURIComponent(url)}`,
                    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                    `https://proxy.cors.sh/${encodeURIComponent(url)}`,
                    url
                ];
            }

            updateProgress(batchNumber = null, totalBatches = null) {
                this.progress = (this.processedFiles / this.totalFiles) * 100;
                
                const progressBar = document.getElementById('zipProgressBar');
                const statusText = document.getElementById('zipStatusText');
                const speedInfo = document.getElementById('zipSpeedInfo');
                
                if (progressBar) {
                    progressBar.style.width = `${this.progress}%`;
                }
                
                if (statusText) {
                    let text = `Downloaded ${this.processedFiles.toLocaleString()}/${this.totalFiles.toLocaleString()} files`;
                    
                    if (batchNumber && totalBatches) {
                        text += ` (Batch ${batchNumber}/${totalBatches})`;
                    }
                    
                    text += ` | Success: ${this.successCount.toLocaleString()} | Failed: ${this.failedCount.toLocaleString()}`;
                    statusText.textContent = text;
                }
                
                if (speedInfo && this.startTime) {
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    if (elapsed > 0) {
                        const filesPerSec = (this.processedFiles / elapsed).toFixed(1);
                        const remainingFiles = this.totalFiles - this.processedFiles;
                        const estTime = remainingFiles / (this.processedFiles / elapsed);
                        
                        let timeText = `Speed: ${filesPerSec} files/sec`;
                        
                        if (estTime > 0 && estTime < 3600) {
                            const minutes = Math.ceil(estTime / 60);
                            timeText += ` | ETA: ${minutes} min`;
                        }
                        
                        speedInfo.textContent = timeText;
                    }
                }
            }

            async forceGarbageCollection() {
                if (window.gc) {
                    window.gc();
                }
                
                if (this.cache.size > 100) {
                    const keys = Array.from(this.cache.keys()).slice(0, 50);
                    keys.forEach(key => this.cache.delete(key));
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            cancel() {
                this.isProcessing = false;
                if (this.abortController) {
                    this.abortController.abort();
                }
            }
        }

        // --- PLAYBACK LOGIC ---
        function switchScreen(type) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (type === 'youtube') {
                screens.yt.classList.add('active');
                modeIndicator.textContent = "MODE: YOUTUBE";
                mp3ActionBtn.classList.add('show');
            } else if (type === 'audio') {
                screens.audio.classList.add('active');
                modeIndicator.textContent = "MODE: AUDIO STREAM";
                mp3ActionBtn.classList.remove('show');
            }
        }

        function playMedia(index) {
            if (index < 0 || index >= playlist.length) return;
            currentIndex = index;
            currentMediaItem = playlist[index];
            renderPlaylist();

            if (currentMediaItem.type === 'youtube') {
                switchScreen('youtube');
                const id = extractYTId(currentMediaItem.url);
                if(id) {
                    youtubePlayer.playVideo(id, false);
                    mp3ActionBtn.onclick = () => { window.open(`https://www.y2mate.com/youtube/${id}`, '_blank'); };
                } else {
                    statusIndicator.textContent = "ERROR: Invalid YouTube URL";
                    ytPlaceholder.style.display = 'flex';
                    ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>INVALID URL`;
                }
            } else if (currentMediaItem.type === 'audio') {
                switchScreen('audio');
                audioEl.src = currentMediaItem.url;
                audioEl.play();
                audioTitle.textContent = fixMojibake(currentMediaItem.name);
                audioPath.textContent = currentMediaItem.path ? fixMojibake(currentMediaItem.path) : "/";
                statusIndicator.textContent = "PLAYING";
                const playBtnIcon = document.querySelector('#playPauseBtn i');
                playBtnIcon.className = 'fas fa-pause';
            }
        }

        loadBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (!url) return;
            if (url.includes('youtube.com') || url.includes('youtu.be')) {
                const videoId = extractYTId(url);
                if (videoId) {
                    addToPlaylist(url, `YouTube: ${videoId}`, 'youtube', 'YouTube Root');
                    playMedia(playlist.length - 1);
                } else {
                    showNotification("Invalid YouTube URL", "error");
                }
            } else if (url.endsWith('.mp3')) {
                const name = url.split('/').pop();
                addToPlaylist(url, name, 'audio', '/');
                playMedia(playlist.length - 1);
            } else {
                document.getElementById('scanInput').value = url;
                openScanner();
            }
        });

        // --- CONTROLS ---
        const playBtn = document.getElementById('playPauseBtn');
        playBtn.addEventListener('click', () => {
            const icon = playBtn.querySelector('i');
            if (currentMediaItem && currentMediaItem.type === 'youtube') {
                const id = extractYTId(currentMediaItem.url);
                if(id) youtubePlayer.playVideo(id, icon.className.includes('fa-play'));
            } else if (currentMediaItem && currentMediaItem.type === 'audio') {
                if(audioEl.paused) { audioEl.play(); icon.className='fas fa-pause'; statusIndicator.textContent = "PLAYING"; }
                else { audioEl.pause(); icon.className='fas fa-play'; statusIndicator.textContent = "PAUSED"; }
            }
        });
        document.getElementById('nextBtn').onclick = () => playMedia((currentIndex + 1) % playlist.length);
        document.getElementById('prevBtn').onclick = () => playMedia((currentIndex - 1 + playlist.length) % playlist.length);
        document.getElementById('clearPlaylistBtn').onclick = () => {
            playlist = []; selectedUids.clear(); currentIndex = -1; isSelectAll = false;
            selectAllBtn.innerHTML = '<i class="fas fa-check-double"></i> SELECT ALL';
            youtubePlayer.stop(); audioEl.pause(); renderPlaylist();
            showNotification("Playlist cleared", "info");
        };

        // --- SELECT ALL LOGIC ---
        selectAllBtn.addEventListener('click', () => {
            if (playlist.length === 0) return;
            isSelectAll = !isSelectAll;
            if (isSelectAll) {
                selectedUids.clear(); playlist.forEach(item => selectedUids.add(item.uid));
                selectAllBtn.innerHTML = '<i class="fas fa-times"></i> DESELECT ALL';
            } else {
                selectedUids.clear();
                selectAllBtn.innerHTML = '<i class="fas fa-check-double"></i> SELECT ALL';
            }
            renderPlaylist();
        });

        // --- PLAYLIST MANAGEMENT ---
        function addToPlaylist(url, name, type, path) {
            const uid = Date.now().toString(36) + Math.random().toString(36).substr(2);
            playlist.push({ url, name, type, path, uid });
            renderPlaylist();
        }

        function toggleSelection(uid) {
            if (selectedUids.has(uid)) selectedUids.delete(uid); else selectedUids.add(uid);
            updateSelectAllState(); renderPlaylist();
        }

        function updateSelectAllState() {
            const allSelected = playlist.length > 0 && playlist.every(item => selectedUids.has(item.uid));
            isSelectAll = allSelected;
            selectAllBtn.innerHTML = allSelected ? '<i class="fas fa-times"></i> DESELECT ALL' : '<i class="fas fa-check-double"></i> SELECT ALL';
        }

        function deleteTrack(uid, event) {
            if(event) event.stopPropagation();
            playlist = playlist.filter(item => item.uid !== uid);
            selectedUids.delete(uid);
            if(currentMediaItem && currentMediaItem.uid === uid) {
                currentMediaItem = null; currentIndex = -1;
                youtubePlayer.stop(); audioEl.pause();
                document.querySelector('#playPauseBtn i').className = 'fas fa-play';
                statusIndicator.textContent = "READY";
            }
            updateSelectAllState(); renderPlaylist();
        }

        function renderPlaylist() {
            const container = document.getElementById('playlistContainer');
            container.innerHTML = '';
            if(playlist.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:var(--text-secondary); padding:30px;">NO DATA</div>';
                playlistTitle.textContent = "DATA STREAM [0/0]"; selectedCountBadge.textContent = "(0)"; return;
            }

            playlist.forEach((item, idx) => {
                const div = document.createElement('div');
                const isSelected = selectedUids.has(item.uid);
                div.className = `playlist-item ${idx === currentIndex ? 'active' : ''}`;
                let icon = item.type === 'youtube' ? '<i class="fab fa-youtube"></i>' : '<i class="fas fa-music"></i>';
                
                const displayName = fixMojibake(item.name);
                let pathDisplay = '';
                if (item.path && item.path !== '/' && item.path !== 'YouTube Root') {
                    const parts = fixMojibake(item.path).split('/').filter(p => p);
                    pathDisplay = parts.join(' <i class="fas fa-chevron-right" style="font-size:8px; margin:0 2px;"></i> ');
                }

                div.innerHTML = `
                    <div class="cyber-check ${isSelected ? 'checked' : ''}" onclick="toggleSelection('${item.uid}')"></div>
                    <div class="track-info-wrapper">
                        <div class="track-path">${pathDisplay}</div>
                        <div class="track-name">${icon} ${displayName}</div>
                    </div>
                    <div class="delete-btn" onclick="deleteTrack('${item.uid}', event)"><i class="fas fa-times"></i></div>
                `;
                div.addEventListener('click', (e) => {
                    if(!e.target.classList.contains('cyber-check') && !e.target.closest('.delete-btn')) playMedia(idx);
                });
                container.appendChild(div);
            });
            playlistTitle.textContent = `DATA STREAM [${selectedUids.size}/${playlist.length}]`;
            selectedCountBadge.textContent = `(${selectedUids.size})`;
        }

        // --- ZIP BUTTON OPTIMISÉ ---
        document.getElementById('downloadZipBtn').addEventListener('click', async () => {
            if (selectedUids.size === 0) {
                showNotification("No songs selected.", "error");
                return;
            }
            
            const selectedItems = playlist.filter(item => selectedUids.has(item.uid));
            const audioItems = selectedItems.filter(item => item.type === 'audio');
            
            if (audioItems.length === 0) {
                showNotification("No audio files to download.", "error");
                return;
            }
            
            if (audioItems.length > 500) {
                const proceed = confirm(
                    `You are about to download ${audioItems.length.toLocaleString()} files.\n` +
                    `This may take a long time and use significant bandwidth.\n` +
                    `Are you sure you want to continue?`
                );
                
                if (!proceed) return;
            }
            
            const zipOverlay = document.getElementById('zipOverlay');
            zipOverlay.style.display = 'flex';
            document.getElementById('zipProgressBar').style.width = '0%';
            document.getElementById('zipStatusText').textContent = 'Initializing download...';
            document.getElementById('cancelZipBtn').style.display = 'inline-block';
            
            try {
                zipGenerator = new OptimizedZipGenerator();
                zipGenerator.isProcessing = true;
                
                document.getElementById('cancelZipBtn').onclick = () => {
                    if (zipGenerator) {
                        zipGenerator.cancel();
                        showNotification("Download cancelled", "info");
                    }
                    zipOverlay.style.display = 'none';
                };
                
                const zip = await zipGenerator.createZip(selectedItems);
                
                if (!zipGenerator.isProcessing) {
                    throw new Error("Download cancelled");
                }
                
                if (zipGenerator.successCount === 0) {
                    throw new Error("No files were successfully downloaded");
                }
                
                document.getElementById('zipProgressBar').style.width = '100%';
                document.getElementById('zipStatusText').textContent = 
                    `Creating archive (${zipGenerator.successCount.toLocaleString()} files)...`;
                
                const content = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 1 },
                    platform: "UNIX"
                });
                
                const elapsed = ((Date.now() - zipGenerator.startTime) / 1000).toFixed(1);
                const sizeMB = (content.size / (1024 * 1024)).toFixed(1);
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `Beatstreet_Collection_${new Date().toISOString().slice(0,10)}_${zipGenerator.successCount}_files.zip`;
                document.body.appendChild(link);
                link.click();
                
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                }, 100);
                
                showNotification(
                    `Success! ${zipGenerator.successCount.toLocaleString()} files (${sizeMB} MB) in ${elapsed}s.`,
                    "success"
                );
                
                setTimeout(() => {
                    zipOverlay.style.display = 'none';
                    document.getElementById('cancelZipBtn').style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error("ZIP Error:", error);
                
                if (error.message.includes("cancelled")) {
                    showNotification("Download cancelled by user", "info");
                } else {
                    showNotification(
                        `ZIP Error: ${error.message}. ` +
                        `Successfully downloaded: ${zipGenerator ? zipGenerator.successCount : 0} files.`,
                        "error"
                    );
                }
                
                zipOverlay.style.display = 'none';
                document.getElementById('cancelZipBtn').style.display = 'none';
            } finally {
                if (zipGenerator) {
                    zipGenerator.isProcessing = false;
                    zipGenerator.cache.clear();
                    zipGenerator = null;
                }
            }
        });

        function extractYTId(url) {
            try {
                const patterns = [
                    /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i,
                    /youtube\.com\/watch\?v=([^&]{11})/, /youtu\.be\/([^?]{11})/
                ];
                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1] && match[1].length === 11) return match[1];
                }
                return null;
            } catch(e) { return null; }
        }

        // --- SCANNER LOGIC ---
        window.openScanner = () => document.getElementById('scannerOverlay').style.display = 'flex';
        window.closeScanner = () => document.getElementById('scannerOverlay').style.display = 'none';

        const PROXIES = [
            (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
            (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
            (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`
        ];

        async function fetchContent(url) {
            for (const proxy of PROXIES) {
                try {
                    const res = await fetch(proxy(url));
                    if(!res.ok) throw new Error(res.status);
                    let content = proxy.toString().includes('allorigins') ? (await res.json()).contents : await res.text();
                    return content;
                } catch(e) { continue; }
            }
            throw new Error("Proxy Access Denied");
        }

        let isScanning = false;
        document.getElementById('startScanBtn').addEventListener('click', async () => {
            const startUrl = document.getElementById('scanInput').value.trim();
            if(!startUrl) return;

            isScanning = true;
            document.getElementById('startScanBtn').style.display = 'none';
            document.getElementById('stopScanBtn').style.display = 'inline-block';
            const log = document.getElementById('scanLog');
            log.innerHTML = "";

            function l(msg, type='') {
                const div = document.createElement('div');
                div.textContent = msg;
                if(type==='found') div.className='found';
                if(type==='error') div.className='error';
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            }

            l("Starting directory scan...");
            
            try {
                const baseUrl = startUrl.endsWith('/') ? startUrl : startUrl + '/';
                const baseUrlObj = new URL(baseUrl);
                const basePath = baseUrlObj.pathname;
                
                l(`Base URL: ${baseUrl}`);
                l(`Scan limited to: ${basePath} and subdirectories`);
                
                const queue = [{ url: baseUrl, depth: 0 }];
                const visited = new Set();
                const maxDepth = 10;

                while(queue.length > 0 && isScanning) {
                    const { url, depth } = queue.shift();
                    
                    if(visited.has(url)) continue;
                    visited.add(url);

                    const currentUrlObj = new URL(url);
                    const currentPath = currentUrlObj.pathname;
                    
                    if (!currentPath.startsWith(basePath)) {
                        l(`Skipping: ${currentPath} (outside base directory)`, 'error');
                        continue;
                    }

                    const relativePath = currentPath.substring(basePath.length);
                    const depthIndicator = "│ ".repeat(Math.min(depth, 5)) + (depth > 0 ? "├─ " : "");
                    l(`${depthIndicator}Scanning: ${relativePath || '/'} (depth: ${depth})`);

                    try {
                        const html = await fetchContent(url);
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a[href]'));

                        const folderLinks = [];
                        const fileLinks = [];

                        links.forEach(link => {
                            const href = link.getAttribute('href');
                            if(!href || href.startsWith('#') || href.includes('?')) return;

                            if(href === '../' || href === './' || href.startsWith('../')) return;

                            try {
                                const resolvedUrl = new URL(href, url).href;
                                
                                const resolvedUrlObj = new URL(resolvedUrl);
                                if(resolvedUrlObj.origin !== baseUrlObj.origin) return;
                                
                                const resolvedPath = resolvedUrlObj.pathname;
                                
                                if (!resolvedPath.startsWith(basePath)) {
                                    return;
                                }

                                if (resolvedUrl.endsWith('/')) {
                                    if(depth < maxDepth && !visited.has(resolvedUrl)) {
                                        folderLinks.push({
                                            url: resolvedUrl,
                                            name: href.replace(/\/$/, ''),
                                            depth: depth + 1
                                        });
                                    }
                                } else if (resolvedUrl.toLowerCase().endsWith('.mp3')) {
                                    fileLinks.push({
                                        url: resolvedUrl,
                                        name: href.split('/').pop()
                                    });
                                }
                            } catch(e) {}
                        });

                        fileLinks.forEach(file => {
                            const fileName = file.name;
                            const filePath = new URL(file.url).pathname;
                            const relativeFilePath = filePath.substring(basePath.length);
                            
                            addToPlaylist(file.url, fileName, 'audio', relativeFilePath);
                            l(`  ${depthIndicator}├─ FOUND: ${fileName}`, 'found');
                        });

                        folderLinks.forEach(folder => {
                            if (!visited.has(folder.url) && depth < maxDepth) {
                                queue.push({ 
                                    url: folder.url, 
                                    depth: folder.depth,
                                    name: folder.name
                                });
                            }
                        });

                    } catch(e) {
                        l(`ERROR fetching ${url}: ${e.message}`, 'error');
                    }
                    
                    await new Promise(r => setTimeout(r, 100));
                }
            } catch(e) {
                l("Scan Critical Error: " + e.message, "error");
            }
            
            if(!isScanning) {
                l("SCAN STOPPED BY USER.", "error");
            } else {
                l("SCAN COMPLETE. All subdirectories have been scanned.");
            }
            
            document.getElementById('startScanBtn').style.display = 'inline-block';
            document.getElementById('stopScanBtn').style.display = 'none';
            isScanning = false;
        });

        document.getElementById('stopScanBtn').addEventListener('click', () => { 
            isScanning = false; 
            document.getElementById('scanLog').innerHTML += '<div class="error">Stopping scan...</div>';
        });
        
        // Initialisation
        window.addEventListener('DOMContentLoaded', () => {
            statusIndicator.textContent = "READY | OPTIMIZED FOR 1000+ FILES";
        });

        // Optimisation mémoire
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (zipGenerator) {
                    zipGenerator.cache.clear();
                }
            }
        });

        window.addEventListener('beforeunload', (e) => {
            if (zipGenerator && zipGenerator.isProcessing) {
                e.preventDefault();
                e.returnValue = "A download is in progress. Are you sure you want to leave?";
                return e.returnValue;
            }
        });
    </script>
</body>
</html>
