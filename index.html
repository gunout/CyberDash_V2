<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BEATSTREET CYBERDASH - Selection Manager</title>
    
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary-cyan: #00ffff;
            --neon-blue: #00f3ff;
            --dark-cyan: #0088aa;
            --accent-blue: #0099ff;
            --bg-dark: #020205;
            --bg-panel: rgba(5, 15, 30, 0.9);
            --text-primary: #e0faff;
            --text-secondary: #00cccc;
            --danger-red: #ff3333;
            --glow-cyan: 0 0 10px rgba(0, 255, 255, 0.6), 0 0 20px rgba(0, 255, 255, 0.4);
            --glow-strong: 0 0 15px var(--neon-blue), 0 0 30px var(--primary-cyan);
        }

        body {
            background: linear-gradient(135deg, #020205 0%, #050a15 50%, #0a0f20 100%);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Background Effects */
        .cyber-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index:1; }
        .particle {
            position: absolute; width: 2px; height: 2px; background: var(--primary-cyan);
            border-radius: 50%; box-shadow: var(--glow-cyan); animation: float 20s infinite linear;
        }
        @keyframes float {
            0% { transform: translateY(100vh) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) translateX(100px); opacity: 0; }
        }
        .grid-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(rgba(0,255,255, 0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,255,255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px; pointer-events: none; z-index: 2;
        }

        /* Layout */
        .dashboard {
            position: relative; z-index: 10;
            height: 100%;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            padding: 20px;
        }

        /* Header */
        .header {
            background: rgba(0, 20, 30, 0.7); border: 1px solid var(--primary-cyan);
            border-radius: 10px; padding: 15px 25px; backdrop-filter: blur(15px);
            box-shadow: var(--glow-cyan); display: flex; justify-content: space-between; align-items: center;
        }
        .logo {
            font-family: 'Orbitron', monospace; font-size: 24px; font-weight: 900;
            text-transform: uppercase; letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--primary-cyan));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .status-bar { display: flex; gap: 15px; font-family: 'Orbitron', monospace; font-size: 12px; }
        .status-item { color: var(--text-secondary); display: flex; align-items: center; gap: 5px; }
        .status-dot { width: 8px; height: 8px; background: var(--primary-cyan); border-radius: 50%; box-shadow: var(--glow-cyan); }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr 250px;
            gap: 20px;
            min-height: 0; 
        }

        /* Panels */
        .panel {
            background: var(--bg-panel); border: 1px solid var(--dark-cyan);
            border-radius: 10px; padding: 15px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        /* Panel Title avec bouton Select All */
        .panel-title {
            font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 700;
            color: var(--primary-cyan); margin-bottom: 15px; border-bottom: 1px solid var(--dark-cyan);
            padding-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* Bouton Select All */
        .select-all-btn {
            background: transparent;
            border: 1px solid var(--primary-cyan);
            color: var(--primary-cyan);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .select-all-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px var(--primary-cyan);
        }

        .select-all-btn i {
            font-size: 10px;
        }

        /* Playlist Container & Scrollbar */
        .playlist-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin-bottom: 15px;
            padding-right: 5px;
        }
        
        .playlist-container::-webkit-scrollbar { width: 10px; }
        .playlist-container::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.6);
            border-radius: 5px;
        }
        .playlist-container::-webkit-scrollbar-thumb {
            background: var(--dark-cyan);
            border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .playlist-container::-webkit-scrollbar-thumb:hover {
            background: var(--primary-cyan);
            box-shadow: 0 0 10px var(--primary-cyan);
        }

        /* Playlist Item */
        .playlist-item {
            background: rgba(0,255,255, 0.03); border-left: 3px solid var(--dark-cyan);
            padding: 10px; margin-bottom: 5px; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 10px;
            position: relative;
        }
        
        /* Checkbox Style */
        .cyber-check {
            width: 18px; height: 18px;
            border: 1px solid var(--primary-cyan);
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            position: relative;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .cyber-check:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px var(--primary-cyan);
        }

        /* Checked State */
        .cyber-check.checked {
            background: var(--primary-cyan);
            box-shadow: 0 0 10px var(--primary-cyan);
        }

        .cyber-check.checked::after {
            content: '✓';
            color: #000;
            font-weight: bold;
            font-size: 12px;
        }

        /* Delete Button */
        .delete-btn {
            opacity: 0;
            background: var(--danger-red);
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: absolute;
            right: -10px;
        }

        .playlist-item:hover .delete-btn {
            opacity: 1;
            right: 10px;
        }

        .delete-btn:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px var(--danger-red);
        }

        .playlist-item:hover {
            background: rgba(0,255,255, 0.1);
            border-left-color: var(--primary-cyan);
            transform: translateX(2px);
        }

        .playlist-item.active {
            background: rgba(0,255,255, 0.15); border-left-color: #fff;
            box-shadow: 0 0 10px rgba(0,255,255,0.1);
        }

        /* Track Info */
        .track-info-wrapper {
            flex: 1;
            min-width: 0;
            display: flex; flex-direction: column; gap: 4px;
        }

        .track-path {
            font-size: 11px; color: var(--text-secondary); opacity: 0.8;
            font-family: monospace; display: flex; align-items: center; gap: 5px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .track-path i { color: var(--primary-cyan); font-size: 10px; }
        
        .track-name {
            font-size: 13px; font-weight: 600; color: #fff;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: flex; align-items: center; gap: 8px;
        }

        /* ZIP Button */
        .download-zip-btn {
            background: linear-gradient(45deg, var(--primary-cyan), var(--accent-blue));
            border: none; color: #000; padding: 12px; border-radius: 5px;
            font-family: 'Orbitron'; font-weight: 700; cursor: pointer; text-transform: uppercase;
            font-size: 12px; box-shadow: var(--glow-cyan); transition: 0.3s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            flex-shrink: 0;
        }
        .download-zip-btn:hover { transform: translateY(-2px); box-shadow: var(--glow-strong); }
        .download-zip-btn small { font-size: 10px; opacity: 0.8; }

        /* Center Media Deck */
        .media-deck { flex: 1; display: flex; flex-direction: column; }
        
        .deck-input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .cyber-input {
            flex:1; background: rgba(0, 10, 20, 0.9); border: 1px solid var(--dark-cyan);
            border-radius: 4px; padding: 10px; color: var(--primary-cyan);
            font-family: 'Rajdhani', sans-serif; font-size: 14px; outline: none;
        }
        .cyber-btn {
            background: rgba(0,255,255, 0.1); border: 1px solid var(--primary-cyan);
            color: var(--primary-cyan); padding: 0 20px; border-radius: 4px; cursor: pointer;
            font-family: 'Orbitron', monospace; font-weight: 700; text-transform: uppercase;
            transition: all 0.3s;
        }
        .cyber-btn:hover { background: var(--primary-cyan); color: #000; box-shadow: var(--glow-cyan); }

        /* The Visual Screen */
        .screen-container {
            flex: 1; background: #000; border: 1px solid var(--dark-cyan); border-radius: 8px;
            position: relative; overflow: hidden; display: flex; flex-direction: column;
        }
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 20;
        }
        .corner-decor {
            position: absolute; width: 15px; height: 15px; border: 2px solid var(--primary-cyan);
            opacity: 0.5; z-index: 21;
        }
        .tl { top: 10px; left: 10px; border-right: none; border-bottom: none; }
        .br { bottom: 10px; right: 10px; border-left: none; border-top: none; }

        .screen-content {
            flex: 1; position: relative; display: none; justify-content: center; align-items: center;
        }
        .screen-content.active { display: flex; }

        /* YouTube Mode */
        .yt-placeholder { 
            position: absolute; 
            text-align: center; 
            color: var(--dark-cyan); 
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
        }
        .yt-placeholder i { font-size: 50px; margin-bottom: 15px; opacity: 0.3; }
        
        /* Container pour le lecteur YouTube */
        .yt-player-container {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 10;
        }

        .yt-player-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Audio Mode */
        .audio-player-ui {
            width: 100%; padding: 20px; text-align: center; color: var(--primary-cyan);
            display: flex; flex-direction: column; justify-content: center; gap: 20px; height: 100%;
        }
        .audio-info-title { font-family: 'Orbitron'; font-size: 18px; text-shadow: 0 0 10px var(--primary-cyan); word-break: break-all; }
        .audio-info-path { font-family: 'Rajdhani'; font-size: 14px; opacity: 0.7; }
        
        .audio-wave {
            height: 100px; display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        .bar { width: 10px; background: var(--primary-cyan); animation: wave 1s infinite ease-in-out; }
        @keyframes wave { 0%, 100% { height: 10px; opacity: 0.5; } 50% { height: 80px; opacity: 1; box-shadow: 0 0 10px var(--primary-cyan); } }
        
        /* Controls Bar */
        .control-bar {
            background: rgba(0, 20, 30, 0.9); border-top: 1px solid var(--primary-cyan);
            padding: 12px; display: flex; justify-content: space-between; align-items: center; z-index: 25;
        }
        .bar-left { font-family: 'Orbitron'; font-size: 11px; color: var(--text-secondary); }
        .bar-controls { display: flex; gap: 10px; }
        .icon-btn {
            background: transparent; border: none; color: var(--primary-cyan); cursor: pointer; font-size: 18px;
            transition: 0.2s;
        }
        .icon-btn:hover { color: #fff; text-shadow: 0 0 10px var(--primary-cyan); transform: scale(1.1); }
        .mp3-action-btn {
            background: rgba(255, 0, 0, 0.1); border: 1px solid #ff3333; color: #ff3333;
            padding: 5px 12px; border-radius: 4px; cursor: pointer; font-family: 'Orbitron'; font-size: 10px;
            text-transform: uppercase; display: none;
        }
        .mp3-action-btn.show { display: block; }
        .mp3-action-btn:hover { background: #ff0000; color: #fff; }

        /* Scanner Overlay */
        .scanner-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 5, 10, 0.95); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(15px);
        }
        .scanner-box {
            background: var(--bg-panel); border: 2px solid var(--primary-cyan);
            padding: 30px; width: 600px; border-radius: 10px; box-shadow: var(--glow-strong); text-align: center;
        }
        .scan-input {
            width: 100%; background: #000; border: 1px solid var(--dark-cyan);
            color: var(--primary-cyan); padding: 12px; margin: 20px 0; font-family: 'Rajdhani'; font-size: 16px;
        }
        .scan-log {
            height: 200px; overflow-y: auto; background: #000; color: var(--primary-cyan);
            font-family: monospace; font-size: 11px; text-align: left; padding: 10px;
            border: 1px solid var(--dark-cyan); margin-top: 15px;
        }
        .scan-log .depth-1 { color: #00ffff; }
        .scan-log .found { color: #ff00ff; font-weight: bold; }
        .scan-log .error { color: #ff0000; }

        /* ZIP Progress */
        .zip-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 3000;
        }
        .zip-box {
            background: var(--bg-panel); border: 2px solid var(--primary-cyan); padding: 30px;
            width: 400px; text-align: center; border-radius: 10px;
        }
        .zip-bar-bg { width: 100%; height: 10px; background: #000; margin: 20px 0; }
        .zip-bar-fill { height: 100%; background: var(--primary-cyan); width: 0%; transition: width 0.3s; }

        @media(max-width: 900px) { .main-content { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="cyber-bg" id="cyberBg"></div>
    <div class="grid-overlay"></div>

    <div class="dashboard">
        <header class="header">
            <div class="logo">BEATSTREET <span style="color:var(--primary-cyan)">SELECTOR</span></div>
            <div class="status-bar">
                <div class="status-item"><div class="status-dot"></div> ONLINE</div>
                <div class="status-item"><div class="status-dot" style="background:#ffff00"></div> MANAGER</div>
            </div>
        </header>

        <main class="main-content">
            <!-- Playlist Panel -->
            <section class="panel">
                <div class="panel-title">
                    <span id="playlistTitle">DATA STREAM [0/0]</span>
                    <div>
                        <button class="select-all-btn" id="selectAllBtn">
                            <i class="fas fa-check-double"></i> SELECT ALL
                        </button>
                        <i class="fas fa-database"></i>
                    </div>
                </div>
                <div class="playlist-container" id="playlistContainer">
                    <div style="text-align:center; color:var(--text-secondary); padding:30px; opacity:0.5;">NO DATA</div>
                </div>
                <button class="download-zip-btn" id="downloadZipBtn">
                    <i class="fas fa-file-archive"></i> ZIP SELECTED
                    <small id="selectedCountBadge">(0)</small>
                </button>
            </section>

            <!-- Media Deck Panel -->
            <section class="panel media-deck">
                <div class="deck-input-group">
                    <input type="text" class="cyber-input" id="urlInput" placeholder="ENTER YOUTUBE URL OR MP3 LINK...">
                    <button class="cyber-btn" id="loadBtn">LOAD</button>
                </div>

                <div class="screen-container" id="screenContainer">
                    <div class="corner-decor tl"></div>
                    <div class="corner-decor br"></div>
                    <div class="scanlines"></div>

                    <!-- Mode 1: YouTube -->
                    <div class="screen-content active" id="ytScreen">
                        <div class="yt-placeholder" id="ytPlaceholder">
                            <i class="fab fa-youtube"></i><br>READY TO PLAY
                        </div>
                        <div class="yt-player-container" id="ytPlayerContainer">
                            <!-- Le lecteur sera injecté ici -->
                        </div>
                    </div>

                    <!-- Mode 2: Audio -->
                    <div class="screen-content" id="audioScreen">
                        <div class="audio-player-ui">
                            <div class="audio-info-title" id="audioTitle">NO TRACK</div>
                            <div class="audio-info-path" id="audioPath">WAITING...</div>
                            <div class="audio-wave">
                                <div class="bar" style="animation-delay:0.1s"></div>
                                <div class="bar" style="animation-delay:0.3s"></div>
                                <div class="bar" style="animation-delay:0.5s"></div>
                                <div class="bar" style="animation-delay:0.2s"></div>
                                <div class="bar" style="animation-delay:0.4s"></div>
                            </div>
                        </div>
                        <audio id="html5Audio" controls style="width:100%; position:absolute; bottom:0; opacity:0;"></audio>
                    </div>
                </div>

                <div class="control-bar">
                    <div class="bar-left">
                        <span id="modeIndicator">MODE: YOUTUBE</span>
                        <br>
                        <span id="statusIndicator" style="color:var(--primary-cyan)">READY</span>
                    </div>
                    <div class="bar-controls">
                        <button class="icon-btn" id="prevBtn"><i class="fas fa-step-backward"></i></button>
                        <button class="icon-btn" id="playPauseBtn"><i class="fas fa-play"></i></button>
                        <button class="icon-btn" id="nextBtn"><i class="fas fa-step-forward"></i></button>
                        <button class="mp3-action-btn" id="mp3ActionBtn"><i class="fas fa-download"></i> GET MP3</button>
                    </div>
                </div>
            </section>

            <!-- Settings -->
            <section class="panel">
                <div class="panel-title">CONTROLS</div>
                <div style="margin-top:auto; text-align:center;">
                    <button class="cyber-btn" onclick="openScanner()" style="width:100%; margin-bottom:10px; border-color:var(--accent-blue); color:var(--accent-blue);">
                        <i class="fas fa-search"></i> DEEP SCAN
                    </button>
                    <button class="cyber-btn" id="clearPlaylistBtn" style="width:100%; background:rgba(255,0,0,0.1); border-color:red; color:red;">
                        <i class="fas fa-trash"></i> CLEAR ALL
                    </button>
                </div>
            </section>
        </main>
    </div>

    <!-- SCANNER OVERLAY -->
    <div class="scanner-overlay" id="scannerOverlay">
        <div class="scanner-box">
            <h2 style="font-family:'Orbitron'; color:var(--primary-cyan);">RECURSIVE CRAWLER</h2>
            <input type="text" class="scan-input" id="scanInput" value="http://hoj-clan.fr/Music/Skid%20Row/">
            <div class="scan-log" id="scanLog">> System ready...</div>
            <div style="margin-top:15px;">
                <button class="cyber-btn" id="startScanBtn" style="background:rgba(0,255,0,0.1); border-color:#0f0; color:#0f0;">START CRAWL</button>
                <button class="cyber-btn" id="stopScanBtn" style="background:rgba(255,0,0,0.1); border-color:red; color:red; display:none;">
                    <i class="fas fa-stop"></i> STOP SCAN
                </button>
                <button class="cyber-btn" onclick="closeScanner()" style="margin-left:10px;">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- ZIP PROGRESS OVERLAY -->
    <div class="zip-overlay" id="zipOverlay">
        <div class="zip-box">
            <h2 style="font-family:'Orbitron'; color:var(--primary-cyan); margin-bottom:15px;">CREATING ARCHIVE</h2>
            <div id="zipStatusText">Organizing folders...</div>
            <div class="zip-bar-bg">
                <div class="zip-bar-fill" id="zipProgressBar"></div>
            </div>
            <div id="zipSpeedInfo" style="margin-top:10px; font-size:12px; color:var(--text-secondary);"></div>
        </div>
    </div>

    <script>
        // --- PARTICLES ---
        const cyberBg = document.getElementById('cyberBg');
        for(let i=0; i<40; i++) {
            const p = document.createElement('div'); p.className='particle';
            p.style.left = Math.random()*100+'%'; p.style.animationDelay = Math.random()*20+'s';
            cyberBg.appendChild(p);
        }

        // --- STATE ---
        let playlist = [];
        let selectedUids = new Set();
        let currentIndex = -1;
        let currentMediaItem = null;
        let isSelectAll = false;
        let currentYouTubePlayer = null;

        // --- DOM ---
        const screens = {
            yt: document.getElementById('ytScreen'),
            audio: document.getElementById('audioScreen')
        };
        const urlInput = document.getElementById('urlInput');
        const loadBtn = document.getElementById('loadBtn');
        const modeIndicator = document.getElementById('modeIndicator');
        const statusIndicator = document.getElementById('statusIndicator');
        const playlistTitle = document.getElementById('playlistTitle');
        const selectedCountBadge = document.getElementById('selectedCountBadge');
        const selectAllBtn = document.getElementById('selectAllBtn');
        
        const ytPlaceholder = document.getElementById('ytPlaceholder');
        const ytPlayerContainer = document.getElementById('ytPlayerContainer');
        const audioEl = document.getElementById('html5Audio');
        const audioTitle = document.getElementById('audioTitle');
        const audioPath = document.getElementById('audioPath');
        const mp3ActionBtn = document.getElementById('mp3ActionBtn');

        // --- YOUTUBE PLAYER INTELLIGENT (GitHub Pages compatible) ---
        class SmartYouTubePlayer {
            constructor() {
                this.currentMethod = null;
                this.currentVideoId = null;
                this.availableMethods = [
                    'githubMethod',     // Méthode optimisée pour GitHub Pages
                    'invidiousMethod',  // Invidious (toujours fonctionnel)
                    'pipedMethod',      // Piped (alternative)
                    'liteMethod',       // YouTube Lite
                    'embedMethod'       // Embedding classique
                ];
                this.methodAttempts = 0;
                this.maxAttempts = 3;
            }

            // Méthode 1: Optimisé pour GitHub Pages
            githubMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        
                        // Utiliser un iframe avec des paramètres spécifiques pour GitHub
                        const iframe = document.createElement('iframe');
                        iframe.id = 'ytGithubPlayer';
                        iframe.src = `https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1&autoplay=${autoplay ? 1 : 0}&playsinline=1`;
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%';
                        iframe.style.height = '100%';
                        iframe.style.border = 'none';
                        
                        ytPlayerContainer.appendChild(iframe);
                        
                        // GitHub Pages a souvent moins de restrictions
                        setTimeout(() => {
                            ytPlaceholder.style.display = 'none';
                            this.currentMethod = 'github';
                            resolve(true);
                        }, 1500);
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Méthode 2: Invidious (open source, fiable)
            invidiousMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        
                        const iframe = document.createElement('iframe');
                        iframe.id = 'ytInvidiousPlayer';
                        
                        // Instances Invidious fiables
                        const instances = [
                            `https://invidious.nerdvpn.de/embed/${videoId}`,
                            `https://y.com.sb/embed/${videoId}`,
                            `https://inv.odyssey346.dev/embed/${videoId}`,
                            `https://invidious.flokinet.to/embed/${videoId}`
                        ];
                        
                        iframe.src = `${instances[0]}?autoplay=${autoplay ? 1 : 0}`;
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%';
                        iframe.style.height = '100%';
                        iframe.style.border = 'none';
                        
                        ytPlayerContainer.appendChild(iframe);
                        
                        iframe.onload = () => {
                            setTimeout(() => {
                                ytPlaceholder.style.display = 'none';
                                this.currentMethod = 'invidious';
                                resolve(true);
                            }, 1000);
                        };
                        
                        iframe.onerror = () => {
                            // Essayer une autre instance
                            for (let i = 1; i < instances.length; i++) {
                                setTimeout(() => {
                                    iframe.src = `${instances[i]}?autoplay=${autoplay ? 1 : 0}`;
                                }, i * 1000);
                            }
                            setTimeout(() => reject(new Error('All invidious instances failed')), 5000);
                        };
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Méthode 3: YouTube Lite (lightweight)
            liteMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        
                        // YouTube Lite Player
                        const litePlayer = document.createElement('div');
                        litePlayer.innerHTML = `
                            <div style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:#000;">
                                <div style="margin-bottom:20px; text-align:center;">
                                    <i class="fab fa-youtube" style="font-size:48px; color:#ff0000;"></i>
                                    <div style="margin-top:10px; font-size:14px; color:#fff;">YouTube Lite Player</div>
                                </div>
                                <div style="width:90%; max-width:560px;">
                                    <iframe 
                                        src="https://www.youtube.com/embed/${videoId}?rel=0&autoplay=${autoplay ? 1 : 0}&controls=1&modestbranding=1"
                                        style="width:100%; height:315px; border:none; border-radius:8px;"
                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                        allowfullscreen>
                                    </iframe>
                                </div>
                                <div style="margin-top:20px; font-size:12px; color:#888;">
                                    Using lightweight embed method
                                </div>
                            </div>
                        `;
                        
                        ytPlayerContainer.appendChild(litePlayer);
                        
                        setTimeout(() => {
                            ytPlaceholder.style.display = 'none';
                            this.currentMethod = 'lite';
                            resolve(true);
                        }, 2000);
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Méthode 4: Piped (alternative)
            pipedMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        
                        const iframe = document.createElement('iframe');
                        iframe.id = 'ytPipedPlayer';
                        iframe.src = `https://piped.video/embed/${videoId}?autoplay=${autoplay ? 1 : 0}`;
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%';
                        iframe.style.height = '100%';
                        iframe.style.border = 'none';
                        
                        ytPlayerContainer.appendChild(iframe);
                        
                        setTimeout(() => {
                            ytPlaceholder.style.display = 'none';
                            this.currentMethod = 'piped';
                            resolve(true);
                        }, 1500);
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Méthode 5: Embedding classique avec retry
            embedMethod(videoId, autoplay = false) {
                return new Promise((resolve, reject) => {
                    try {
                        ytPlayerContainer.innerHTML = '';
                        
                        const iframe = document.createElement('iframe');
                        iframe.id = 'ytEmbedPlayer';
                        
                        // Différentes configurations d'embedding
                        const embedConfigs = [
                            `https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1&autoplay=${autoplay ? 1 : 0}`,
                            `https://www.youtube.com/embed/${videoId}?rel=0&showinfo=0&autoplay=${autoplay ? 1 : 0}`,
                            `https://www.youtube-nocookie.com/embed/${videoId}?rel=0&autoplay=${autoplay ? 1 : 0}`
                        ];
                        
                        iframe.src = embedConfigs[0];
                        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                        iframe.setAttribute('allowfullscreen', '');
                        iframe.style.width = '100%';
                        iframe.style.height = '100%';
                        iframe.style.border = 'none';
                        
                        ytPlayerContainer.appendChild(iframe);
                        
                        let configIndex = 0;
                        
                        const checkPlayer = () => {
                            setTimeout(() => {
                                try {
                                    // Vérifier si le player fonctionne
                                    if (iframe.contentWindow && iframe.contentWindow.location.href.includes('youtube')) {
                                        ytPlaceholder.style.display = 'none';
                                        this.currentMethod = 'embed';
                                        resolve(true);
                                    } else if (configIndex < embedConfigs.length - 1) {
                                        // Essayer une autre configuration
                                        configIndex++;
                                        iframe.src = embedConfigs[configIndex];
                                        checkPlayer();
                                    } else {
                                        reject(new Error('All embed configs failed'));
                                    }
                                } catch (e) {
                                    if (configIndex < embedConfigs.length - 1) {
                                        configIndex++;
                                        iframe.src = embedConfigs[configIndex];
                                        checkPlayer();
                                    } else {
                                        reject(e);
                                    }
                                }
                            }, 2000);
                        };
                        
                        checkPlayer();
                        
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Jouer une vidéo avec méthode intelligente
            async playVideo(videoId, autoplay = false) {
                this.currentVideoId = videoId;
                this.methodAttempts = 0;
                
                // Afficher le loading
                ytPlaceholder.style.display = 'flex';
                ytPlaceholder.innerHTML = `
                    <i class="fab fa-youtube"></i><br>
                    INITIALIZING PLAYER...<br>
                    <div style="margin-top:10px; font-size:12px; opacity:0.7;">
                        GitHub Pages optimized
                    </div>
                `;
                
                // Essayer les méthodes dans l'ordre
                for (const method of this.availableMethods) {
                    this.methodAttempts++;
                    
                    try {
                        ytPlaceholder.innerHTML = `
                            <i class="fab fa-youtube"></i><br>
                            TRYING METHOD ${this.methodAttempts}/5...<br>
                            <div style="margin-top:10px; font-size:12px; opacity:0.7;">
                                ${method.replace('Method', '').toUpperCase()}
                            </div>
                        `;
                        
                        await this[method](videoId, autoplay);
                        
                        // Succès
                        statusIndicator.textContent = autoplay ? "PLAYING" : "READY";
                        const playBtnIcon = document.querySelector('#playPauseBtn i');
                        playBtnIcon.className = autoplay ? 'fas fa-pause' : 'fas fa-play';
                        
                        console.log(`YouTube player loaded successfully with method: ${method}`);
                        return true;
                        
                    } catch (error) {
                        console.warn(`Method ${method} failed:`, error);
                        continue;
                    }
                }
                
                // Toutes les méthodes ont échoué
                this.showFallback(videoId);
                return false;
            }

            // Fallback avec lien direct
            showFallback(videoId) {
                ytPlayerContainer.innerHTML = '';
                ytPlaceholder.style.display = 'flex';
                ytPlaceholder.innerHTML = `
                    <div style="text-align:center; padding:20px;">
                        <i class="fab fa-youtube" style="font-size:60px; color:#ff0000; margin-bottom:20px;"></i>
                        <div style="font-size:16px; margin-bottom:10px; color:var(--primary-cyan);">DIRECT PLAYER</div>
                        <div style="font-size:13px; margin-bottom:20px; opacity:0.8;">
                            Using alternative player method
                        </div>
                        <div style="width:100%; max-width:560px; margin:0 auto;">
                            <iframe 
                                src="https://www.youtube-nocookie.com/embed/${videoId}"
                                style="width:100%; height:315px; border:none; border-radius:8px;"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                allowfullscreen>
                            </iframe>
                        </div>
                        <div style="margin-top:20px; font-size:12px; opacity:0.7;">
                            If player doesn't work, 
                            <a href="https://www.youtube.com/watch?v=${videoId}" target="_blank" style="color:var(--primary-cyan);">
                                click here to watch on YouTube
                            </a>
                        </div>
                    </div>
                `;
                statusIndicator.textContent = "ALTERNATIVE PLAYER";
            }

            // Arrêter le player
            stop() {
                ytPlayerContainer.innerHTML = '';
                ytPlaceholder.style.display = 'flex';
                ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>READY TO PLAY`;
                this.currentMethod = null;
            }
        }

        // Créer le player intelligent
        const youtubePlayer = new SmartYouTubePlayer();

        // --- ZIP GENERATOR AVEC NETTOYAGE DES %20 ---
        class CleanZipGenerator {
            constructor() {
                this.maxWorkers = 8; // 8 connexions parallèles pour GitHub Pages
                this.progress = 0;
                this.totalFiles = 0;
                this.processedFiles = 0;
                this.startTime = null;
                this.successCount = 0;
                this.failedCount = 0;
            }

            // Nettoyer les noms de fichiers (enlever %20 et autres encodages)
            cleanFileName(filename) {
                if (!filename) return 'unknown.mp3';
                
                // Décoder les URL encodées
                let clean = decodeURIComponent(filename);
                
                // Remplacer les espaces et caractères spéciaux
                clean = clean.replace(/%20/g, ' ')
                             .replace(/%2C/g, ',')
                             .replace(/%2F/g, '-')
                             .replace(/%3A/g, '-')
                             .replace(/%5B/g, '(')
                             .replace(/%5D/g, ')')
                             .replace(/%26/g, '&')
                             .replace(/%3F/g, '');
                
                // Nettoyer les caractères invalides pour les noms de fichiers
                clean = clean.replace(/[<>:"|?*]/g, '_')
                             .replace(/\\/g, '-')
                             .replace(/\//g, '-')
                             .replace(/\.\./g, '.');
                
                // S'assurer que l'extension est .mp3
                if (!clean.toLowerCase().endsWith('.mp3')) {
                    clean += '.mp3';
                }
                
                // Limiter la longueur
                if (clean.length > 100) {
                    const parts = clean.split('.');
                    const ext = parts.pop();
                    const name = parts.join('.').substring(0, 60);
                    clean = `${name}...${ext}`;
                }
                
                return clean;
            }

            // Nettoyer le chemin complet
            cleanPath(path) {
                if (!path) return 'downloads/';
                
                // Décoder le chemin
                let cleanPath = decodeURIComponent(path);
                
                // Remplacer les %20 par des espaces
                cleanPath = cleanPath.replace(/%20/g, ' ');
                
                // Nettoyer chaque segment du chemin
                const segments = cleanPath.split('/');
                const cleanedSegments = segments.map(segment => {
                    if (!segment) return '';
                    return this.cleanFileName(segment);
                });
                
                // Reconstruire le chemin
                cleanPath = cleanedSegments.filter(s => s).join('/');
                
                // S'assurer qu'il commence par "Music/" pour l'organisation
                if (!cleanPath.toLowerCase().startsWith('music/')) {
                    cleanPath = 'Music/' + cleanPath;
                }
                
                return cleanPath;
            }

            async createZip(items) {
                this.startTime = Date.now();
                const audioItems = items.filter(item => item.type === 'audio');
                this.totalFiles = audioItems.length;
                this.processedFiles = 0;
                this.successCount = 0;
                this.failedCount = 0;
                
                if (this.totalFiles === 0) {
                    return null;
                }

                const zip = new JSZip();
                
                // Télécharger en parallèle par lots
                const chunkSize = Math.max(1, Math.ceil(audioItems.length / this.maxWorkers));
                const chunks = this.chunkArray(audioItems, chunkSize);
                
                const downloadPromises = chunks.map((chunk, index) => 
                    this.downloadChunk(chunk, index)
                );
                
                const results = await Promise.allSettled(downloadPromises);
                
                // Ajouter les fichiers réussis au ZIP
                for (const result of results) {
                    if (result.status === 'fulfilled') {
                        const downloadedFiles = result.value;
                        for (const [path, blob] of Object.entries(downloadedFiles)) {
                            if (blob && blob.size > 1024) { // Au moins 1KB
                                zip.file(path, blob);
                                this.successCount++;
                            } else {
                                this.failedCount++;
                            }
                        }
                    }
                }

                return zip;
            }

            chunkArray(array, size) {
                const chunks = [];
                for (let i = 0; i < array.length; i += size) {
                    chunks.push(array.slice(i, i + size));
                }
                return chunks;
            }

            async downloadChunk(chunk, chunkIndex) {
                const results = {};
                
                for (const item of chunk) {
                    try {
                        const blob = await this.downloadFile(item.url);
                        if (blob && blob.size > 1024) {
                            // Nettoyer le nom de fichier et le chemin
                            const cleanName = this.cleanFileName(item.name);
                            const cleanPath = this.cleanPath(item.path);
                            
                            // Créer le chemin final
                            let finalPath = cleanPath;
                            if (finalPath.endsWith('/')) {
                                finalPath += cleanName;
                            } else if (!finalPath.includes('.')) {
                                finalPath += '/' + cleanName;
                            }
                            
                            results[finalPath] = blob;
                        }
                    } catch (e) {
                        console.warn(`Failed to download ${item.name}:`, e.message);
                        this.failedCount++;
                    } finally {
                        this.processedFiles++;
                        this.updateProgress();
                    }
                }
                
                return results;
            }

            async downloadFile(url) {
                // Proxies pour contourner CORS (GitHub Pages compatible)
                const proxies = [
                    u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                    u => `https://corsproxy.io/?${encodeURIComponent(u)}`,
                    u => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
                    u => `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(u)}`
                ];

                for (const proxy of proxies) {
                    try {
                        const proxyUrl = proxy(url);
                        const response = await fetch(proxyUrl, {
                            signal: AbortSignal.timeout(15000), // 15 secondes timeout
                            headers: {
                                'User-Agent': 'Beatstreet-Downloader/1.0'
                            }
                        });
                        
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const blob = await response.blob();
                        if (blob.size > 0) {
                            return blob;
                        }
                    } catch (e) {
                        continue; // Essayer le proxy suivant
                    }
                }
                
                throw new Error("All download methods failed");
            }

            updateProgress() {
                this.progress = (this.processedFiles / this.totalFiles) * 100;
                
                const progressBar = document.getElementById('zipProgressBar');
                const statusText = document.getElementById('zipStatusText');
                const speedInfo = document.getElementById('zipSpeedInfo');
                
                if (progressBar) progressBar.style.width = this.progress + '%';
                if (statusText) {
                    statusText.textContent = `Processed ${this.processedFiles}/${this.totalFiles} files (${this.successCount}成功, ${this.failedCount}失败)`;
                }
                
                if (this.startTime && speedInfo) {
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    if (elapsed > 0) {
                        const speed = this.processedFiles / elapsed;
                        speedInfo.textContent = `速度: ${speed.toFixed(1)} 文件/秒 | 成功: ${this.successCount}`;
                    }
                }
            }

            getProgress() {
                return this.progress;
            }
        }

        // --- PLAYBACK LOGIC ---
        function switchScreen(type) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (type === 'youtube') {
                screens.yt.classList.add('active');
                modeIndicator.textContent = "MODE: YOUTUBE";
                mp3ActionBtn.classList.add('show');
            } else if (type === 'audio') {
                screens.audio.classList.add('active');
                modeIndicator.textContent = "MODE: AUDIO STREAM";
                mp3ActionBtn.classList.remove('show');
            }
        }

        function playMedia(index) {
            if (index < 0 || index >= playlist.length) return;
            currentIndex = index;
            currentMediaItem = playlist[index];

            renderPlaylist();

            if (currentMediaItem.type === 'youtube') {
                switchScreen('youtube');
                const id = extractYTId(currentMediaItem.url);
                
                if(id) {
                    youtubePlayer.playVideo(id, false);
                    
                    // Mettre à jour le bouton MP3
                    mp3ActionBtn.onclick = () => {
                        window.open(`https://youtubemultidownloader.org/en/?url=${encodeURIComponent(currentMediaItem.url)}`, '_blank');
                    };
                } else {
                    statusIndicator.textContent = "ERROR: Invalid YouTube URL";
                    ytPlaceholder.style.display = 'flex';
                    ytPlaceholder.innerHTML = `<i class="fab fa-youtube"></i><br>INVALID URL`;
                }

            } else if (currentMediaItem.type === 'audio') {
                switchScreen('audio');
                audioEl.src = currentMediaItem.url;
                audioEl.play();
                audioTitle.textContent = decodeURIComponent(currentMediaItem.name); // Décoder le nom
                if(currentMediaItem.path) {
                    audioPath.textContent = decodeURIComponent(currentMediaItem.path); // Décoder le chemin
                } else {
                    audioPath.textContent = "/";
                }
                statusIndicator.textContent = "PLAYING";
                
                const playBtnIcon = document.querySelector('#playPauseBtn i');
                playBtnIcon.className = 'fas fa-pause';
            }
        }

        loadBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (!url) return;

            if (url.includes('youtube.com') || url.includes('youtu.be')) {
                const videoId = extractYTId(url);
                if (videoId) {
                    // Décoder le nom pour l'affichage
                    const decodedName = decodeURIComponent(url.split('/').pop() || `YouTube: ${videoId}`);
                    addToPlaylist(url, decodedName, 'youtube', 'YouTube Root');
                    playMedia(playlist.length - 1);
                } else {
                    alert("Invalid YouTube URL");
                }
            } else if (url.endsWith('.mp3')) {
                const decodedName = decodeURIComponent(url.split('/').pop());
                addToPlaylist(url, decodedName, 'audio', '/');
                playMedia(playlist.length - 1);
            } else {
                document.getElementById('scanInput').value = url;
                openScanner();
            }
        });

        // --- CONTROLS (PLAY/PAUSE) ---
        const playBtn = document.getElementById('playPauseBtn');
        playBtn.addEventListener('click', () => {
            const icon = playBtn.querySelector('i');
            if (currentMediaItem && currentMediaItem.type === 'youtube') {
                const id = extractYTId(currentMediaItem.url);
                if (id) {
                    if (icon.className.includes('fa-play')) {
                        youtubePlayer.playVideo(id, true);
                    } else {
                        youtubePlayer.playVideo(id, false);
                    }
                }
            } else if (currentMediaItem && currentMediaItem.type === 'audio') {
                if(audioEl.paused) { 
                    audioEl.play(); 
                    icon.className='fas fa-pause'; 
                    statusIndicator.textContent = "PLAYING";
                }
                else { 
                    audioEl.pause(); 
                    icon.className='fas fa-play'; 
                    statusIndicator.textContent = "PAUSED";
                }
            }
        });

        document.getElementById('nextBtn').onclick = () => playMedia((currentIndex + 1) % playlist.length);
        document.getElementById('prevBtn').onclick = () => playMedia((currentIndex - 1 + playlist.length) % playlist.length);
        
        document.getElementById('clearPlaylistBtn').onclick = () => {
            playlist = [];
            selectedUids.clear();
            currentIndex = -1;
            isSelectAll = false;
            selectAllBtn.innerHTML = '<i class="fas fa-check-double"></i> SELECT ALL';
            
            youtubePlayer.stop();
            audioEl.pause();
            renderPlaylist();
        };

        // --- BOUTON SELECT ALL ---
        selectAllBtn.addEventListener('click', () => {
            if (playlist.length === 0) return;
            
            isSelectAll = !isSelectAll;
            
            if (isSelectAll) {
                selectedUids.clear();
                playlist.forEach(item => {
                    selectedUids.add(item.uid);
                });
                selectAllBtn.innerHTML = '<i class="fas fa-times"></i> DESELECT ALL';
            } else {
                selectedUids.clear();
                selectAllBtn.innerHTML = '<i class="fas fa-check-double"></i> SELECT ALL';
            }
            
            renderPlaylist();
        });

        // --- PLAYLIST MANAGEMENT ---
        function addToPlaylist(url, name, type, path) {
            const uid = Date.now().toString(36) + Math.random().toString(36).substr(2);
            playlist.push({ url, name, type, path, uid });
            renderPlaylist();
        }

        function toggleSelection(uid) {
            if (selectedUids.has(uid)) {
                selectedUids.delete(uid);
            } else {
                selectedUids.add(uid);
            }
            
            updateSelectAllState();
            renderPlaylist();
        }

        function updateSelectAllState() {
            const allSelected = playlist.length > 0 && playlist.every(item => selectedUids.has(item.uid));
            
            if (allSelected) {
                isSelectAll = true;
                selectAllBtn.innerHTML = '<i class="fas fa-times"></i> DESELECT ALL';
            } else {
                isSelectAll = false;
                selectAllBtn.innerHTML = '<i class="fas fa-check-double"></i> SELECT ALL';
            }
        }

        function deleteTrack(uid, event) {
            if(event) event.stopPropagation();
            
            playlist = playlist.filter(item => item.uid !== uid);
            selectedUids.delete(uid);
            
            if(currentMediaItem && currentMediaItem.uid === uid) {
                currentMediaItem = null;
                currentIndex = -1;
                
                youtubePlayer.stop();
                audioEl.pause();
                
                const playBtnIcon = document.querySelector('#playPauseBtn i');
                playBtnIcon.className = 'fas fa-play';
                statusIndicator.textContent = "READY";
            }
            
            updateSelectAllState();
            renderPlaylist();
        }

        function renderPlaylist() {
            const container = document.getElementById('playlistContainer');
            container.innerHTML = '';
            
            if(playlist.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:var(--text-secondary); padding:30px;">NO DATA</div>';
                playlistTitle.textContent = "DATA STREAM [0/0]";
                selectedCountBadge.textContent = "(0)";
                return;
            }

            playlist.forEach((item, idx) => {
                const div = document.createElement('div');
                const isSelected = selectedUids.has(item.uid);
                div.className = `playlist-item ${idx === currentIndex ? 'active' : ''}`;
                
                let icon = '';
                if(item.type === 'youtube') icon = '<i class="fab fa-youtube"></i>';
                else if(item.type === 'audio') icon = '<i class="fas fa-music"></i>';

                let pathDisplay = '';
                if (item.path && item.path !== '/' && item.path !== 'YouTube Root') {
                    const parts = decodeURIComponent(item.path).split('/').filter(p => p);
                    pathDisplay = parts.join(' <i class="fas fa-chevron-right" style="font-size:8px; margin:0 2px;"></i> ');
                }

                div.innerHTML = `
                    <div class="cyber-check ${isSelected ? 'checked' : ''}" onclick="toggleSelection('${item.uid}')"></div>
                    <div class="track-info-wrapper">
                        <div class="track-path">${pathDisplay}</div>
                        <div class="track-name">${icon} ${decodeURIComponent(item.name)}</div>
                    </div>
                    <div class="delete-btn" onclick="deleteTrack('${item.uid}', event)">
                        <i class="fas fa-times"></i>
                    </div>
                `;
                
                div.addEventListener('click', (e) => {
                    if(!e.target.classList.contains('cyber-check') && !e.target.closest('.delete-btn')) {
                        playMedia(idx);
                    }
                });
                
                container.appendChild(div);
            });

            playlistTitle.textContent = `DATA STREAM [${selectedUids.size}/${playlist.length}]`;
            selectedCountBadge.textContent = `(${selectedUids.size})`;
        }

        // --- ZIP AVEC NETTOYAGE ---
        document.getElementById('downloadZipBtn').addEventListener('click', async () => {
            if(selectedUids.size === 0) {
                alert("Please select songs first by checking the boxes.");
                return;
            }
            
            const selectedItems = playlist.filter(item => selectedUids.has(item.uid));
            const audioItems = selectedItems.filter(item => item.type === 'audio');
            
            if(audioItems.length === 0) {
                alert("No audio files selected for download.");
                return;
            }

            const zipOverlay = document.getElementById('zipOverlay');
            const progressBar = document.getElementById('zipProgressBar');
            const statusText = document.getElementById('zipStatusText');
            const speedInfo = document.getElementById('zipSpeedInfo');

            zipOverlay.style.display = 'flex';
            progressBar.style.width = '0%';
            statusText.textContent = `Starting download of ${audioItems.length} files...`;
            speedInfo.textContent = "";

            try {
                const zipGenerator = new CleanZipGenerator();
                const zip = await zipGenerator.createZip(selectedItems);
                
                if (!zip || zipGenerator.successCount === 0) {
                    throw new Error(`Download failed. Success: ${zipGenerator.successCount}/${audioItems.length}`);
                }

                progressBar.style.width = '100%';
                statusText.textContent = "Creating final ZIP archive...";
                
                const content = await zip.generateAsync({
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 1 }
                });
                
                const elapsed = (Date.now() - zipGenerator.startTime) / 1000;
                const speed = zipGenerator.successCount / elapsed;
                
                speedInfo.textContent = `Completed in ${elapsed.toFixed(1)}s | Speed: ${speed.toFixed(1)} files/sec | Cleaned filenames`;
                
                // Télécharger
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `Beatstreet_Clean_${Date.now()}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => {
                    alert(`✓ Successfully downloaded ${zipGenerator.successCount} files!\n• Time: ${elapsed.toFixed(1)} seconds\n• Speed: ${speed.toFixed(1)} files/sec\n• Filenames cleaned (no %20)`);
                    zipOverlay.style.display = 'none';
                    progressBar.style.width = '0%';
                }, 500);
                
            } catch(e) {
                console.error("ZIP creation error:", e);
                alert("Error: " + e.message);
                zipOverlay.style.display = 'none';
                progressBar.style.width = '0%';
            }
        });

        function extractYTId(url) {
            try {
                const patterns = [
                    /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i,
                    /youtube\.com\/watch\?v=([^&]{11})/,
                    /youtu\.be\/([^?]{11})/,
                    /youtube\.com\/embed\/([^?]{11})/,
                    /youtube\.com\/v\/([^?]{11})/
                ];
                
                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match && match[1] && match[1].length === 11) {
                        return match[1];
                    }
                }
                
                return null;
            } catch(e) {
                console.error("Error extracting YouTube ID:", e);
                return null;
            }
        }

        // Initialisation
        window.addEventListener('DOMContentLoaded', () => {
            // URL d'exemple
            urlInput.value = 'https://www.youtube.com/watch?v=2_JyKGP5QLQ';
            statusIndicator.textContent = "READY | GitHub Pages";
        });

        // Exposer les fonctions globales
        window.openScanner = openScanner;
        window.closeScanner = closeScanner;
        window.toggleSelection = toggleSelection;
        window.deleteTrack = deleteTrack;

        // Scanner functions
        function openScanner() { 
            document.getElementById('scannerOverlay').style.display = 'flex'; 
        }
        function closeScanner() { 
            document.getElementById('scannerOverlay').style.display = 'none'; 
        }

        // Scanner logic
        const PROXIES = [
            (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
            (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
            (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`
        ];

        async function fetchContent(url) {
            for (let i = 0; i < PROXIES.length; i++) {
                try {
                    const proxyUrl = PROXIES[i](url);
                    const res = await fetch(proxyUrl);
                    if(!res.ok) throw new Error(res.status);
                    let content = proxyUrl.includes('allorigins') ? (await res.json()).contents : await res.text();
                    return content;
                } catch(e) { continue; }
            }
            throw new Error("Proxy Access Denied");
        }

        let isScanning = false;

        document.getElementById('startScanBtn').addEventListener('click', async () => {
            const startUrl = document.getElementById('scanInput').value.trim();
            if(!startUrl) return;

            isScanning = true;
            document.getElementById('startScanBtn').style.display = 'none';
            document.getElementById('stopScanBtn').style.display = 'inline-block';
            
            const log = document.getElementById('scanLog');
            log.innerHTML = "";

            function l(msg, type='') {
                const div = document.createElement('div');
                div.textContent = msg;
                if(type==='found') div.className='found';
                if(type==='error') div.className='error';
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            }

            l("Starting deep recursive scan...");

            const rootUrlObj = new URL(startUrl);
            const rootUrl = rootUrlObj.href.endsWith('/') ? rootUrlObj.href : rootUrlObj.href + '/';

            const queue = [{ url: startUrl, depth: 0 }];
            const visited = new Set();
            const maxDepth = 20;

            while(queue.length > 0 && isScanning) {
                const { url, depth } = queue.shift();
                
                if(visited.has(url)) continue;
                visited.add(url);

                let relativePath = url.replace(rootUrlObj.origin, '');
                if(relativePath.startsWith('/')) relativePath = relativePath.substring(1);

                const depthClass = depth < 2 ? 'depth-1' : '';
                l(`[DEPTH ${depth}] ${decodeURIComponent(relativePath.replace(/\/$/, ''))}`, depthClass);

                try {
                    const html = await fetchContent(url);
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = Array.from(doc.querySelectorAll('a'));

                    links.forEach(link => {
                        const href = link.getAttribute('href');
                        if(!href) return;

                        try {
                            if(href.startsWith('../') || href.includes('?')) return;
                            if(href.startsWith('#')) return;

                            const absUrl = new URL(href, url).href;
                            
                            if(!absUrl.includes(rootUrlObj.origin)) return;

                            if(absUrl.toLowerCase().endsWith('.mp3')) {
                                const fileName = decodeURIComponent(absUrl.split('/').pop());
                                const filePath = decodeURIComponent(absUrl.replace(rootUrlObj.origin, '')); 
                                
                                addToPlaylist(absUrl, fileName, 'audio', filePath);
                                l(`  → FOUND: ${fileName}`, 'found');
                            } else if (absUrl.endsWith('/') && depth < maxDepth) {
                                if(!visited.has(absUrl)) queue.push({ url: absUrl, depth: depth + 1 });
                            }
                        } catch(e){}
                    });
                } catch(e) {
                    l(`ERROR: ${e.message}`, 'error');
                }
                await new Promise(r => setTimeout(r, 200));
            }
            
            if(!isScanning) {
                l("SCAN STOPPED BY USER.");
            } else {
                l("SCAN COMPLETE.");
                document.getElementById('startScanBtn').style.display = 'inline-block';
                document.getElementById('stopScanBtn').style.display = 'none';
                isScanning = false;
            }
        });

        document.getElementById('stopScanBtn').addEventListener('click', () => {
            isScanning = false;
        });
    </script>
</body>

</html>
